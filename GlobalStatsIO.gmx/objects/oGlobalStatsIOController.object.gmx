<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// @description initialize globalstats.io stuff

if (singleton()) {exit;}

// initialize enums for the rank and highscores array
enum RankResult { Key = 0, Name = 0, Value = 1, Sorting = 2, Rank = 3, UpdatedAt = 4, UserProfileURL = 5, UserIconURL = 6};


// initialize properly with your globalstats.io auto_generated game id and secret
gameID = "Nb9jbGnvyg0W973Rc20kczKZ3Le5JUGx6PQhweN5";
gameSecret = "N2EV5v87vtj4dj8ZxdJsUgyK7QglEmQrount0vBw";
highscoreGTD = "high";// GTD (table) for highscores

settingsFile = "globalstatsio.dat";

// try to load GlobalStatsIO settings from file
settings = gs_loadSettings(settingsFile);
settingsChanged = false;


playerNickname = "anonymous";
// the player id from GlobalStats.IO. Is given after first score upload. Undefined otherwise.
playerID = gs_getPlayerID();
if (is_undefined(playerID))
    show_debug_message("oGlobalStatsIOController Create event: player id not yet defined.");


// handles for pending remote calls
accessRequest = -1;// retrieve a new access token
shareRequest = -1;// share a score
rankRequest = -1;// request the current rank of current player
scoresRequest = -1;// request a given number of highscores
shareFirstTimeRequest = -1;// share a score for the first time, get a player id back!
linkRequest = -1;// connect your local player account with a globalstats.io account


// status variables
gsConnected = false;
// JSON response string and decoded map from GlobalStats.IO
gsResponse = noone;
gsResponseMap = noone;
gsLastError = noone;// string of JSON error message

// sending GTD score results are stored in here
gsLastGTDRank = 0;// an array containing your current rank results for your latest uploaded score
// highscore results are stored in here
gsRank = 0;// an array containing your current rank results
// highscore results are stored in here
gsHighscores = 0;// a two dimensional array for the highscore table, similar to gsRank array but for all requested entries
gsHighscoresSize = 0;   // nr of entries in the highscore array

// response for link account request will be stored here
gsLinkAccountURL = noone;
gsLinkAccountPIN = noone;


// insanity check
if (gameID == "NotSet" || gameSecret == "NotSet") {
    show_debug_message("oGlobalStatsIOController Create event: Game ID and Game Secret not yet set!");
    exit;
}

// request an access token

alarm[0] = 1;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// @description access token is invalid, request a new one

gsAccessToken = noone;
gsAccessValidUntil = -1;
accessRequest = gs_getAccessToken(gameID, gameSecret);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// @description save settings in case they have changed and OS is'nt busy.

if (os_is_paused() &amp;&amp; settingsChanged) {
    gs_saveSettings(settingsFile, settings);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="62">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// @description all HTTP responses will land here and need to be treated

var result = gs_getResultID();
var retval, expiresin, valueslist, i, entries;

if (result == accessRequest) {
    gsConnected = false;
    if (gs_getResultStatus()) {
        // request successful. Now do something with it.
        gsConnected = true;
        // accessToken stays valid for an hour
        gsAccessToken = ds_map_find_value(gsResponseMap, "access_token");
        expiresin = ds_map_find_value(gsResponseMap, "expires_in");
        // expiresin is time in seconds
        gsAccessValidUntil = current_time + (expiresin * 1000);
        // start an alarm to request access again when token becomes invalid
        // use the following line for GMS 2
//        alarm[0] = game_get_speed(gamespeed_fps) * expiresin;
        alarm[0] = room_speed * expiresin;
        gsAccessTokenType = ds_map_find_value(gsResponseMap, "token_type");
    }
    accessRequest = -1;
} else if (result == shareFirstTimeRequest) {
    if (gs_getResultStatus()) {
        // request successful.
        // retrieve and store player id
        playerID = ds_map_find_value(gsResponseMap, "_id");
        if (!is_undefined(playerID))
            gs_setPlayerID(playerID);
        // retrieve high score values
        valueslist = ds_map_find_value(gsResponseMap, "values");
        // this is just the entry for the score just shared
        gsLastGTDRank = 0;
        var map = ds_list_find_value(valueslist, 0);
        gsLastGTDRank[RankResult.Key] = ds_map_find_value(map, "key");
        gsLastGTDRank[RankResult.Value] = ds_map_find_value(map, "value");
        gsLastGTDRank[RankResult.Sorting] = ds_map_find_value(map, "sorting");
        gsLastGTDRank[RankResult.Rank] = ds_map_find_value(map, "rank");
        gsLastGTDRank[RankResult.UpdatedAt] = ds_map_find_value(map, "updated_at");
    }
    shareFirstTimeRequest = -1;
} else if (result == shareRequest) {
    if (gs_getResultStatus()) {
        // request successful.
        // retrieve high score values
        valueslist = ds_map_find_value(gsResponseMap, "values");
        gsLastGTDRank = 0;
        var map = ds_list_find_value(valueslist, 0);
        gsLastGTDRank[RankResult.Key] = ds_map_find_value(map, "key");
        gsLastGTDRank[RankResult.Value] = ds_map_find_value(map, "value");
        gsLastGTDRank[RankResult.Sorting] = ds_map_find_value(map, "sorting");
        gsLastGTDRank[RankResult.Rank] = ds_map_find_value(map, "rank");
        gsLastGTDRank[RankResult.UpdatedAt] = ds_map_find_value(map, "updated_at");
    }
    shareRequest = -1;
} else if (result == rankRequest) {
    if (gs_getResultStatus()) {
        // request successful.
        // retrieve current rank of player
        valueslist = ds_map_find_value(gsResponseMap, "statistics");
        gsRank = 0;
        var map = ds_list_find_value(valueslist, 0);
        gsRank[RankResult.Key] = ds_map_find_value(map, "key");
        gsRank[RankResult.Value] = ds_map_find_value(map, "value");
        gsRank[RankResult.Sorting] = ds_map_find_value(map, "sorting");
        gsRank[RankResult.Rank] = ds_map_find_value(map, "rank");
        gsRank[RankResult.UpdatedAt] = ds_map_find_value(map, "updated_at");
    }
    rankRequest = -1;
} else if (result == scoresRequest) {
    if (gs_getResultStatus()) {
        // request successful.
        // retrieve highscorelist
        valueslist = ds_map_find_value(gsResponseMap, "data");
        // this is the list with all highscore entries / gtd entries
        // store it in the gsHighscores array
        gsHighscores = 0;
        entries = ds_list_size(valueslist);
        gsHighscoresSize = entries;
        for (i = 0; i &lt; entries; i++) {
            var map = ds_list_find_value(valueslist, i);
            gsHighscores[i, RankResult.Name] = ds_map_find_value(map, "name");
            gsHighscores[i, RankResult.Rank] = ds_map_find_value(map, "rank");
            gsHighscores[i, RankResult.Value] = ds_map_find_value(map, "value");
            gsHighscores[i, RankResult.UserProfileURL] = ds_map_find_value(map, "user_profile");
            gsHighscores[i, RankResult.UserIconURL] = ds_map_find_value(map, "user_icon");
        }
    }
    scoresRequest = -1;
} else if (result == linkRequest) {
    if (gs_getResultStatus()) {
        // request successful.
        // retrieve link account url and pin
        gsLinkAccountURL = ds_map_find_value(gsResponseMap, "url");
        gsLinkAccountPIN = ds_map_find_value(gsResponseMap, "pin");
    }
    linkRequest = -1;
} else {
    show_debug_message("oGlobalStatsIOController Async HTTP: unexpected response received...");
}
if (gsResponseMap != noone) {
    ds_map_destroy(gsResponseMap);
    gsResponseMap = noone;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// @description save the settings when room ends

show_debug_message("oGlobalStatsIOController: Room End event, saving settings");
gs_saveSettings(settingsFile, settings);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// @description save the settings when game ends

show_debug_message("oGlobalStatsIOController: Game End event, saving settings");
gs_saveSettings(settingsFile, settings);

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
