<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// @description initialize globalstats.io stuff

if (singleton()) {exit;}

// initialize enums for the rank and highscores array
enum RankResult { Name = 0, Value = 1, Sorting = 2, Rank = 3, UpdatedAt = 4, UserProfileURL = 5, UserIconURL = 6, Key = 7};

// enum for achievement lists
enum AchievementResult { Key = 0, Name = 1, Description = 2, ImageActiveURL = 3, ImageInactiveURL = 4, Accomplished = 5};


// initialize properly with your globalstats.io auto_generated game id and secret
gameID = "Nb9jbGnvyg0W973Rc20kczKZ3Le5JUGx6PQhweN5";
gameSecret = "N2EV5v87vtj4dj8ZxdJsUgyK7QglEmQrount0vBw";
highscoreGTD = "high";// GTD (table) for highscores

settingsFile = "globalstatsio.dat";

// try to load GlobalStatsIO settings from file
settings = gs_loadSettings(settingsFile);
settingsChanged = false;


playerNickname = "anonymous";
// the player id from GlobalStats.IO. Is given after first score upload. Undefined otherwise.
playerID = gs_getPlayerID();
if (is_undefined(playerID))
    show_debug_message("oGlobalStatsIOController Create event: player id not yet defined.");


// handles for pending remote calls
accessRequest = -1;// retrieve a new access token
shareRequest = -1;// share a score
rankRequest = -1;// request the current rank of current player
rankSectionRequest = -1;// request the current rank of current player and the closest 5 better and worse ranks of other players
scoresRequest = -1;// request a given number of highscores
shareFirstTimeRequest = -1;// share a score for the first time, get a player id back!
linkRequest = -1;// connect your local player account with a globalstats.io account
allAchievementsRequest = -1;    // request a list of all achievements of this game
playerAchievementsRequest = -1; // request a list of all achievements where each entry is flagged if the player accomplished the achievement
accomplishAchievementRequest = -1;  // mark an achievement as accomplished


// status variables
gsConnected = false;
// JSON response string and decoded map from GlobalStats.IO
gsResponse = noone;
gsResponseMap = noone;
gsLastError = noone;// string of JSON error message

// sending GTD score results are stored in here
gsLastGTDRank = 0;// an array containing your current rank results for your latest uploaded score
// highscore results are stored in here
gsRank = 0;// an array containing your current rank results

// additional arrays for rank section with better and worse players. Player's rank is stored in gsRank, declared above
gsWorseRanks = 0;
gsWorseRanksSize = 0;
gsBetterRanks = 0;
gsBetterRanksSize = 0;

// highscore results are stored in here
gsHighscores = 0;// a two dimensional array for the highscore table, similar to gsRank array but for all requested entries
gsHighscoresSize = 0;   // nr of entries in the highscore array

// response for link account request will be stored here
gsLinkAccountURL = noone;
gsLinkAccountPIN = noone;

// some more arrays for achievements
gsAllAchievements = 0;      // an array of all achievements which are available in this game
gsAllAchievementsSize = 0;
gsPlayerAchievements = 0;   // an array of the achievements the player already received
gsPlayerAchievementsSize = 0;
gsLatestAchievements = 0;      // an array containing the latest achievements, obtained by the last GTD update
gsLatestAchievementsSize = 0;   // nr of above array
gsAchievementSprites = 0;       // a ds_map containing the url of an achievement sprite as key and the sprite from the loaded image as value
gsAchievementSprites = ds_map_create();
gsPendingAchievementSprites = ds_map_create();  // a ds_map for pending sprites. This means they are requested to be loaded but not yet there
gsAccomplishedAchievement = 0;  // an array containing the elements of the manually accomplished achievement

// callback scripts
gsErrorCallback = noone;
gsAccomplishedCallback = noone;


// insanity check
if (gameID == "NotSet" || gameSecret == "NotSet") {
    show_debug_message("oGlobalStatsIOController Create event: Game ID and Game Secret not yet set!");
    exit;
}

// request an access token

alarm[0] = 1;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// @description access token is invalid, request a new one

gsAccessToken = noone;
gsAccessValidUntil = -1;
accessRequest = gs_getAccessToken(gameID, gameSecret);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// @description save settings in case they have changed and OS is'nt busy.

if (os_is_paused() &amp;&amp; settingsChanged) {
    gs_saveSettings(settingsFile, settings);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="62">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// @description all HTTP responses will land here and need to be treated

var result = gs_getResultID();
var retval, expiresin, valueslist, achievementlist, i, entries;

show_debug_message("oGlobalStatsIOController.http_event: response received, request id was " + string(result));

if (result == accessRequest) {
    gsConnected = false;
    if (gs_getResultStatus()) {
        // request successful. Now do something with it.
        gsConnected = true;
        // accessToken stays valid for an hour
        gsAccessToken = ds_map_find_value(gsResponseMap, "access_token");
        expiresin = ds_map_find_value(gsResponseMap, "expires_in");
        // expiresin is time in seconds
        gsAccessValidUntil = current_time + (expiresin * 1000);
        // start an alarm to request access again when token becomes invalid
        // use the following line for GMS 2
//        alarm[0] = game_get_speed(gamespeed_fps) * expiresin;
        alarm[0] = room_speed * expiresin;
        gsAccessTokenType = ds_map_find_value(gsResponseMap, "token_type");
    }
    accessRequest = -1;
} else if (result == shareFirstTimeRequest) {
    if (gs_getResultStatus()) {
        // request successful.
        // retrieve and store player id
        playerID = ds_map_find_value(gsResponseMap, "_id");
        if (!is_undefined(playerID))
            gs_setPlayerID(playerID);
        // retrieve high score values
        valueslist = ds_map_find_value(gsResponseMap, "values");
        // this is just the entry for the score just shared
        gsLastGTDRank = 0;
        gsLastGTDRank[RankResult.Name] = ds_map_find_value(gsResponseMap, "name");
        var map = ds_list_find_value(valueslist, 0);
        gsLastGTDRank[RankResult.Key] = ds_map_find_value(map, "key");
        gsLastGTDRank[RankResult.Value] = ds_map_find_value(map, "value");
        gsLastGTDRank[RankResult.Sorting] = ds_map_find_value(map, "sorting");
        gsLastGTDRank[RankResult.Rank] = ds_map_find_value(map, "rank");
        gsLastGTDRank[RankResult.UpdatedAt] = ds_map_find_value(map, "updated_at");
        // retrieve list of achievements that might have been fulfilled with the update of this GTD
        achievementlist = ds_map_find_value(gsResponseMap, "achievements");
        entries = ds_list_size(achievementlist);
        gsLatestAchievementsSize = entries;
        for (i = 0; i &lt; entries; i++) {
            var entrymap = ds_list_find_value(achievementlist, i);
            gsLatestAchievements[i, AchievementResult.Key] = ds_map_find_value(entrymap, "key");
            gsLatestAchievements[i, AchievementResult.Name] = ds_map_find_value(entrymap, "name");
            gsLatestAchievements[i, AchievementResult.Description] = ds_map_find_value(entrymap, "description");
            gsLatestAchievements[i, AchievementResult.ImageActiveURL] = ds_map_find_value(entrymap, "image_active");
            gsLatestAchievements[i, AchievementResult.ImageInactiveURL] = ds_map_find_value(entrymap, "image_inactive");
        }
        if (entries &gt; 0) {
            if (gsAccomplishedCallback != noone)
                script_execute(gsAccomplishedCallback, gsLatestAchievements, gsLatestAchievementsSize);
        }
    }
    shareFirstTimeRequest = -1;
} else if (result == shareRequest) {
    if (gs_getResultStatus()) {
        // request successful.
        // retrieve high score values
        valueslist = ds_map_find_value(gsResponseMap, "values");
        gsLastGTDRank = 0;
        gsLastGTDRank[RankResult.Name] = ds_map_find_value(gsResponseMap, "name");
        var map = ds_list_find_value(valueslist, 0);
        gsLastGTDRank[RankResult.Key] = ds_map_find_value(map, "key");
        gsLastGTDRank[RankResult.Value] = ds_map_find_value(map, "value");
        gsLastGTDRank[RankResult.Sorting] = ds_map_find_value(map, "sorting");
        gsLastGTDRank[RankResult.Rank] = ds_map_find_value(map, "rank");
        gsLastGTDRank[RankResult.UpdatedAt] = ds_map_find_value(map, "updated_at");
        // retrieve list of achievements that might have been fulfilled with the update of this GTD
        achievementlist = ds_map_find_value(gsResponseMap, "achievements");
        entries = ds_list_size(achievementlist);
        gsLatestAchievementsSize = entries;
        for (i = 0; i &lt; entries; i++) {
            var entrymap = ds_list_find_value(achievementlist, i);
            gsLatestAchievements[i, AchievementResult.Key] = ds_map_find_value(entrymap, "key");
            gsLatestAchievements[i, AchievementResult.Name] = ds_map_find_value(entrymap, "name");
            gsLatestAchievements[i, AchievementResult.Description] = ds_map_find_value(entrymap, "description");
            gsLatestAchievements[i, AchievementResult.ImageActiveURL] = ds_map_find_value(entrymap, "image_active");
            gsLatestAchievements[i, AchievementResult.ImageInactiveURL] = ds_map_find_value(entrymap, "image_inactive");
        }
        if (entries &gt; 0) {
            if (gsAccomplishedCallback != noone)
                script_execute(gsAccomplishedCallback, gsLatestAchievements, gsLatestAchievementsSize);
        }
    }
    shareRequest = -1;
} else if (result == rankRequest) {
    if (gs_getResultStatus()) {
        // request successful.
        // retrieve current rank of player
        valueslist = ds_map_find_value(gsResponseMap, "statistics");
        gsRank = 0;
        gsRank[RankResult.Name] = ds_map_find_value(gsResponseMap, "name");
        var map = ds_list_find_value(valueslist, 0);
        gsRank[RankResult.Key] = ds_map_find_value(map, "key");
        gsRank[RankResult.Value] = ds_map_find_value(map, "value");
        gsRank[RankResult.Sorting] = ds_map_find_value(map, "sorting");
        gsRank[RankResult.Rank] = ds_map_find_value(map, "rank");
        gsRank[RankResult.UpdatedAt] = ds_map_find_value(map, "updated_at");
    }
    rankRequest = -1;
} else if (result == rankSectionRequest) {
    if (gs_getResultStatus()) {
        // request successful.
        // first retrieve rank of current player
        var map;
        map = ds_map_find_value(gsResponseMap, "user_rank");
        gsRank = 0;
        gsRank[RankResult.Name] = ds_map_find_value(map, "name");
        gsRank[RankResult.Rank] = ds_map_find_value(map, "rank");
        gsRank[RankResult.Value] = ds_map_find_value(map, "value");
        gsRank[RankResult.UserProfileURL] = ds_map_find_value(map, "user_profile");
        gsRank[RankResult.UserIconURL] = ds_map_find_value(map, "user_icon");
        // next retrieve list of better players
        map = ds_map_find_value(gsResponseMap, "better_ranks");
        valueslist = ds_map_find_value(map, "data");
        // this is the list with all better scores
        // store it in the gsBetterRanks array
        gsBetterRanks = 0;
        entries = ds_list_size(valueslist);
        gsBetterRanksSize = entries;
        for (i = 0; i &lt; entries; i++) {
            var entrymap = ds_list_find_value(valueslist, i);
            gsBetterRanks[i, RankResult.Name] = ds_map_find_value(entrymap, "name");
            gsBetterRanks[i, RankResult.Rank] = ds_map_find_value(entrymap, "rank");
            gsBetterRanks[i, RankResult.Value] = ds_map_find_value(entrymap, "value");
            gsBetterRanks[i, RankResult.UserProfileURL] = ds_map_find_value(entrymap, "user_profile");
            gsBetterRanks[i, RankResult.UserIconURL] = ds_map_find_value(entrymap, "user_icon");
        }
        // finally retrieve list of worse players
        map = ds_map_find_value(gsResponseMap, "worse_ranks");
        valueslist = ds_map_find_value(map, "data");
        // this is the list with all worse scores
        // store it in the gsWorseRanks array
        gsWorseRanks = 0;
        entries = ds_list_size(valueslist);
        gsWorseRanksSize = entries;
        for (i = 0; i &lt; entries; i++) {
            var entrymap = ds_list_find_value(valueslist, i);
            gsWorseRanks[i, RankResult.Name] = ds_map_find_value(entrymap, "name");
            gsWorseRanks[i, RankResult.Rank] = ds_map_find_value(entrymap, "rank");
            gsWorseRanks[i, RankResult.Value] = ds_map_find_value(entrymap, "value");
            gsWorseRanks[i, RankResult.UserProfileURL] = ds_map_find_value(entrymap, "user_profile");
            gsWorseRanks[i, RankResult.UserIconURL] = ds_map_find_value(entrymap, "user_icon");
        }
    }
    rankSectionRequest = -1;
} else if (result == scoresRequest) {
    if (gs_getResultStatus()) {
        // request successful.
        // retrieve highscorelist
        valueslist = ds_map_find_value(gsResponseMap, "data");
        // this is the list with all highscore entries / gtd entries
        // store it in the gsHighscores array
        gsHighscores = 0;
        entries = ds_list_size(valueslist);
        gsHighscoresSize = entries;
        for (i = 0; i &lt; entries; i++) {
            var map = ds_list_find_value(valueslist, i);
            gsHighscores[i, RankResult.Name] = ds_map_find_value(map, "name");
            gsHighscores[i, RankResult.Rank] = ds_map_find_value(map, "rank");
            gsHighscores[i, RankResult.Value] = ds_map_find_value(map, "value");
            gsHighscores[i, RankResult.UserProfileURL] = ds_map_find_value(map, "user_profile");
            gsHighscores[i, RankResult.UserIconURL] = ds_map_find_value(map, "user_icon");
        }
    }
    scoresRequest = -1;
} else if (result == linkRequest) {
    if (gs_getResultStatus()) {
        // request successful.
        // retrieve link account url and pin
        gsLinkAccountURL = ds_map_find_value(gsResponseMap, "url");
        gsLinkAccountPIN = ds_map_find_value(gsResponseMap, "pin");
    }
    linkRequest = -1;
} else if (result == allAchievementsRequest) {
    if (gs_getResultStatus()) {
        // request successful.
        // retrieve list of all available achievements in the game
        valueslist = ds_map_find_value(gsResponseMap, "achievements");
        // this is the list with all possible achievements
        // store it in the gsAllAchievements array
        gsAllAchievements = 0;
        entries = ds_list_size(valueslist);
        gsAllAchievementsSize = entries;
        for (i = 0; i &lt; entries; i++) {
            var map = ds_list_find_value(valueslist, i);
            gsAllAchievements[i, AchievementResult.Key] = ds_map_find_value(map, "key");
            gsAllAchievements[i, AchievementResult.Name] = ds_map_find_value(map, "name");
            gsAllAchievements[i, AchievementResult.Description] = ds_map_find_value(map, "description");
            gsAllAchievements[i, AchievementResult.ImageActiveURL] = ds_map_find_value(map, "image_active");
            gsAllAchievements[i, AchievementResult.ImageInactiveURL] = ds_map_find_value(map, "image_inactive");
        }
    }
    allAchievementsRequest = -1;
} else if (result == playerAchievementsRequest) {
    if (gs_getResultStatus()) {
        // request successful.
        // retrieve list of player achievements in the game, is basically a list of all achievements with
        // additional information for each achievement if it has been accomplished by the given player or not
        valueslist = ds_map_find_value(gsResponseMap, "achievements");
        // this is the list with all possible achievements
        // store it in the gsAllAchievements array
        gsPlayerAchievements = 0;
        entries = ds_list_size(valueslist);
        gsPlayerAchievementsSize = entries;
        for (i = 0; i &lt; entries; i++) {
            var map = ds_list_find_value(valueslist, i);
            gsPlayerAchievements[i, AchievementResult.Key] = ds_map_find_value(map, "key");
            gsPlayerAchievements[i, AchievementResult.Name] = ds_map_find_value(map, "name");
            gsPlayerAchievements[i, AchievementResult.Description] = ds_map_find_value(map, "description");
            gsPlayerAchievements[i, AchievementResult.ImageActiveURL] = ds_map_find_value(map, "image_active");
            gsPlayerAchievements[i, AchievementResult.ImageInactiveURL] = ds_map_find_value(map, "image_inactive");
            gsPlayerAchievements[i, AchievementResult.Accomplished] = ds_map_find_value(map, "accomplished");
        }
    }
    playerAchievementsRequest = -1;
} else if (result == accomplishAchievementRequest) {
    if (gs_getResultStatus()) {
        // request successful.
        // retrieve accomplished achievement
        var map = ds_map_find_value(gsResponseMap, "achievement");
        // this is the accomplished achievement
        // store it in the gsAllAchievements array
        gsAccomplishedAchievement = 0;
        gsAccomplishedAchievement[AchievementResult.Key] = ds_map_find_value(map, "key");
        gsAccomplishedAchievement[AchievementResult.Name] = ds_map_find_value(map, "name");
        gsAccomplishedAchievement[AchievementResult.Description] = ds_map_find_value(map, "description");
        gsAccomplishedAchievement[AchievementResult.ImageActiveURL] = ds_map_find_value(map, "image_active");
        gsAccomplishedAchievement[AchievementResult.ImageInactiveURL] = ds_map_find_value(map, "image_inactive");
    }
    accomplishAchievementRequest = -1;
} else {
    show_debug_message("oGlobalStatsIOController Async HTTP: unexpected response received, could be an image load request...");
}
if (gsResponseMap != noone) {
    ds_map_destroy(gsResponseMap);
    gsResponseMap = noone;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="60">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// callback when an achievement image is loaded from globalstats.io
show_debug_message("Async event Image Loaded received");

var spr = gs_getResultID();
var url = ds_map_find_value(async_load, "filename");
var status = ds_map_find_value(async_load, "status");
if (status &gt;= 0) {
    var pendingspr = ds_map_find_value(oGlobalStatsIOController.gsPendingAchievementSprites, url);
    if (is_undefined(pendingspr)) {
        // this should never happen!
        show_debug_message("received a response for sprite url '" + url + "' which was never requested!");
        exit;
    } else {
        if (spr != pendingspr) {
            // this should also never happen!
            show_debug_message("Pending and received sprite ids for url '" + url + "' don't match!");
            exit;
        } else {
            // okay, sprite successfully loaded. Add it to the proper ds_map
            ds_map_add(oGlobalStatsIOController.gsAchievementSprites, url, spr);
            // and delete it from the pending map
            ds_map_delete(oGlobalStatsIOController.gsPendingAchievementSprites, url);
        }
    }
} else {
    // an error occurred on loading the image
    show_debug_message("Error loading sprite for url '" + url + "'!");
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// @description save the settings when room ends

show_debug_message("oGlobalStatsIOController: Room End event, saving settings");
gs_saveSettings(settingsFile, settings);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// @description save the settings when game ends

show_debug_message("oGlobalStatsIOController: Game End event, saving settings");
gs_saveSettings(settingsFile, settings);

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
